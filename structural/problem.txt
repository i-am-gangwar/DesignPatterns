1. Theory
What is it?

The Decorator Pattern lets you dynamically add new behavior or responsibilities to objects at runtime, without changing their code.
Itâ€™s like wrapping a gift box ğŸ in layers of decorative paper â†’ each wrapper adds something new but still keeps the gift usable.

Structure

Component (interface/abstract class) â†’ defines the core behavior.

Concrete Component â†’ the main object we want to decorate.

Decorator (abstract class) â†’ has a reference to a Component, implements Component, and forwards calls.

Concrete Decorators â†’ extend Decorator to add new behavior.

Example (real-world)

Coffee shop â˜•:

Base: SimpleCoffee â†’ â‚¹50

Decorators: MilkDecorator, SugarDecorator

You can wrap coffee with sugar, then milk, etc. â†’ behavior (cost + description) extends dynamically.

Without Decorator

You might use inheritance:

class Coffee {}
class MilkCoffee extends Coffee {}
class SugarCoffee extends Coffee {}
class MilkSugarCoffee extends Coffee {}


ğŸ’¥ Explosion of subclasses as you add combinations.

With Decorator

You compose instead of inherit:

SimpleCoffee wrapped with MilkDecorator wrapped with SugarDecorator.

Flexible, no class explosion.

ğŸ”¹ 2. Problem to Try (Without Decorator First)

Problem: Coffee ordering system.

A Coffee class with a method getCost() and getDescription().

Add-ons: milk (+10), sugar (+5), whipped cream (+15).

Without decorator, youâ€™ll probably add flags/if-else inside Coffee or create multiple subclasses.

ğŸ‘‰ Task for you:

First, try without decorator (maybe using if-else or separate subclasses).

Then weâ€™ll refactor into decorator version.