Observer Design Pattern â€“ Theory
1. Definition
The Observer Pattern is a behavioral design pattern where:
	â€¢ An object (Subject/Publisher) maintains a list of dependents (Observers/Subscribers).
	â€¢ When the subjectâ€™s state changes, it notifies all observers automatically.
ğŸ‘‰ Think: â€œPublishâ€“Subscribe mechanismâ€.

2. Real-World Examples
	â€¢ YouTube channel subscribers â†’ When channel uploads a new video, all subscribers get notified.
	â€¢ Stock market apps â†’ When stock price changes, all registered apps/clients get update.
	â€¢ Weather station â†’ Sensors publish data, multiple displays (phone app, website, smartwatch) observe changes.



3. Key Components
	â€¢ Subject (Observable/Publisher)
		â—‹ Maintains a list of observers.
		â—‹ Provides attach, detach, notify methods.
	â€¢ Observer (Subscriber/Listener)
		â—‹ Defines update() method to be called when subject changes.
	â€¢ Concrete Subject
		â—‹ Stores actual state/data.
		â—‹ Calls notifyObservers() when state changes.
	â€¢ Concrete Observers
		â—‹ React to updates (UI refresh, logs, alerts, etc.).







5. Advantages
âœ… Loose coupling (Subject doesnâ€™t know details of Observers).
âœ… Easy to add/remove observers dynamically.
âœ… Implements â€œpushâ€ mechanism of communication.
6. Disadvantages
âŒ Can cause performance issues if many observers.
âŒ Notifications may arrive in unexpected order.
âŒ Hard to debug if observers have side-effects.


7. When to Use
	â€¢ When one objectâ€™s state change should notify others automatically.
	â€¢ Event-driven systems (GUI, messaging, stock updates).


Problem for You
Scenario:
You are building a Weather Station system.
	â€¢ It collects temperature updates.
	â€¢ Multiple displays (e.g., PhoneDisplay, WebDisplay, TVDisplay) should update automatically whenever temperature changes.
Task:
	1. Without Observer Pattern
		â—‹ Create WeatherStation with a setTemperature() method.
		â—‹ Inside it, manually call update methods of phone, web, and TV displays.
		â—‹ Problem: If you add a new display, you must modify WeatherStation.
	2. With Observer Pattern
		â—‹ Create Subject interface (addObserver, removeObserver, notifyObservers).
		â—‹ WeatherStation is the concrete subject.
		â—‹ Each display implements Observer interface with update(temp).
		â—‹ When temperature changes, station calls notifyObservers().



Push model
What it is: the Subject pushes the data (or event object) to each observer via the update(...) call.
Signature example: observer.update(newTemperature).
Pros
	â€¢ Fewer calls: subject sends exactly the data observers need right away.
	â€¢ Simpler for observers that only need that one piece of info.
	â€¢ Good when the change payload is small and self-contained (e.g., a single numeric temperature).
Cons
	â€¢ Observers become coupled to the pushed data format â€” if you change what you push, many observers may need updates.
	â€¢ If the payload is large, you may waste bandwidth/time pushing unnecessary data.
	â€¢ Harder to extend if observers need more than whatâ€™s pushed.


Pull model
What it is: the Subject notifies observers only that something changed, usually by passing a reference to itself (or no payload). Each observer then pulls whatever state it needs by calling getters on the subject.
Signature example: observer.update(subject) and inside update() the observer calls subject.getTemperature().
Pros
	â€¢ Observers decide what data they want â€” flexible and good when observers need different pieces of state.
	â€¢ Loose coupling of observer to the internal representation (observer only needs accessors).
	â€¢ Easier to change what internal state the subject exposes (via getters) without changing update signature.
Cons
	â€¢ Extra calls: each observer may invoke one or more getters â†’ more interaction.
	â€¢ Observers must know the subject API (need accessors).
	â€¢ If many observers pull heavy state repeatedly, performance may suffer.
When to use
	â€¢ When observers may require different parts of the subjectâ€™s state.
	â€¢ When state is complex and you donâ€™t want to push all of it to every observer.
	â€¢ When you want future flexibility for observers to read additional state without changing notify signature.



Practical considerations & best practices

Snapshot the observer list when notifying (copy to a new list) so observers can add/remove during notification without ConcurrentModificationException.

Threading: if notifications are long-running or you don't want to block the subject, dispatch updates asynchronously (executor/service). But handle ordering if you need strict order.

Error isolation: catch exceptions from observers so one bad observer doesnâ€™t stop the rest.

Event object: instead of primitive push args, consider a small event class (TemperatureChangeEvent { oldTemp, newTemp, time }). This is push but more extensible.

Memory / payload size: donâ€™t push huge objects to many observers â€” either push a small event or let observers pull from the subject.

Deprecation note (Java): Javaâ€™s java.util.Observer/Observable is deprecated â€” prefer custom implementation or event frameworks (RxJava, event buses) or DI frameworks for complex systems.