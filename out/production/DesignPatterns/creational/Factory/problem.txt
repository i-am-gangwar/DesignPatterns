## ğŸ¯ **Factory Method Pattern: Practice Problem**

---

## ğŸ“š **Problem Statement: Design a Payment Processing System Using Factory Pattern**

---

## ğŸ“ **Scenario:**

You are tasked with designing a **Payment Processing System** that supports multiple payment methods. The system should be flexible enough to support:

âœ… Different payment methods, such as:
- **Credit Card**
- **UPI (Unified Payments Interface)**
- **Net Banking**

âœ… New payment methods can be added without modifying existing client code.

âœ… The client should only need to specify the **payment type** and receive an appropriate object that handles the payment.

---

## ğŸ“Œ **Requirements:**

### ğŸ¯ **Functional Requirements:**

1. **Payment Types:**
   - Credit Card Payment
   - UPI Payment
   - Net Banking Payment

2. **Objective:**
   - Use the **Factory Method Pattern** to create appropriate payment objects.
   - The client code should not be aware of the underlying class names.

3. **Payment Interface:**
   - Define a `Payment` interface with a method `processPayment(double amount)`.

4. **Concrete Classes:**
   - `CreditCardPayment`  
   - `UPIPayment`  
   - `NetBankingPayment`  

5. **Factory Class:**
   - `PaymentFactory` class to create appropriate `Payment` objects.

---

## âš¡ï¸ **Challenge:**

âœ… Design the class hierarchy and implement the **Factory Pattern**.  
âœ… Create a `PaymentFactory` class that returns the appropriate payment method.  
âœ… Add a new payment method (`PayPal`) without modifying the existing client code.  

---

## ğŸ¯ **Expected Usage:**

```java
public class Main {
    public static void main(String[] args) {
        // Get Credit Card Payment
        Payment payment1 = PaymentFactory.getPayment("CREDITCARD");
        payment1.processPayment(500.00);

        // Get UPI Payment
        Payment payment2 = PaymentFactory.getPayment("UPI");
        payment2.processPayment(200.00);

        // Get Net Banking Payment
        Payment payment3 = PaymentFactory.getPayment("NETBANKING");
        payment3.processPayment(1000.00);

        // Try Invalid Payment Type
        Payment invalidPayment = PaymentFactory.getPayment("CRYPTO");
        if (invalidPayment == null) {
            System.out.println("Invalid Payment Method Selected!");
        }
    }
}
```

---

## ğŸ”¥ **Bonus Challenge:**

âœ… Add a new payment type: **PayPal Payment**.  
âœ… Implement exception handling for unsupported payment types.  

---

## ğŸ“š **Hints:**

1. Define a `Payment` interface and concrete classes for each payment type.
2. Create a `PaymentFactory` with a method `getPayment(String type)`.
3. Use `switch` or `if-else` in the factory to return the appropriate payment object.
4. Ensure that the client code does not use `new` to create objects directly.

---

## ğŸ‰ **Difficulty Levels:**

- ğŸŸ¢ Basic: Implement 3 payment types with basic factory logic.
- ğŸŸ¡ Intermediate: Add a new payment method dynamically.
- ğŸ”´ Advanced: Implement exception handling and logging for invalid payment types.

---

Ready to give it a try? Let me know if you need any guidance while implementing! ğŸš€ğŸ˜Š